"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8933],{4907:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(9953);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(1943),i=(n(9953),n(4907));const r={},l="Value concepts",o={unversionedId:"reference/pyexp/pyexp-language-definition/value-concepts",id:"reference/pyexp/pyexp-language-definition/value-concepts",title:"Value concepts",description:"Starlark has eleven core data types. An application that embeds the Starlark intepreter may define additional types that behave like Starlark values. All values, whether core or application-defined, implement a few basic behaviors:",source:"@site/docs/reference/pyexp/pyexp-language-definition/value-concepts.md",sourceDirName:"reference/pyexp/pyexp-language-definition",slug:"/reference/pyexp/pyexp-language-definition/value-concepts",permalink:"/docs/reference/pyexp/pyexp-language-definition/value-concepts",draft:!1,editUrl:"https://github.com/raptor-ml/docs/tree/master/docs/reference/pyexp/pyexp-language-definition/value-concepts.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Statements",permalink:"/docs/reference/pyexp/pyexp-language-definition/statements"},next:{title:"Raptor Built-ins",permalink:"/docs/reference/pyexp/raptor-built-ins/"}},s={},p=[{value:"Identity and mutation",id:"identity-and-mutation",level:2},{value:"Freezing a value",id:"freezing-a-value",level:2},{value:"Hashing",id:"hashing",level:2},{value:"Sequence types",id:"sequence-types",level:2},{value:"Indexing",id:"indexing",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"value-concepts"},"Value concepts"),(0,i.kt)("p",null,"Starlark has eleven core ",(0,i.kt)("a",{parentName:"p",href:"data-types"},"data types"),". An application that embeds the Starlark intepreter may define additional types that behave like Starlark values. All values, whether core or application-defined, implement a few basic behaviors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"str(x)      -- return a string representation of x\ntype(x)     -- return a string describing the type of x\nbool(x)     -- convert x to a Boolean truth value\n")),(0,i.kt)("h2",{id:"identity-and-mutation"},"Identity and mutation"),(0,i.kt)("p",null,"Starlark is an imperative language: programs consist of sequences of statements executed for their side effects. For example, an assignment statement updates the value held by a variable, and calls to some built-in functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"print")," change the state of the application that embeds the interpreter."),(0,i.kt)("p",null,"Values of some data types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"NoneType"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", are ",(0,i.kt)("em",{parentName:"p"},"immutable"),"; they can never change. Immutable values have no notion of ",(0,i.kt)("em",{parentName:"p"},"identity"),": it is impossible for a Starlark program to tell whether two integers, for instance, are represented by the same object; it can tell only whether they are equal."),(0,i.kt)("p",null,"Values of other data types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),", are ",(0,i.kt)("em",{parentName:"p"},"mutable"),": they may be modified by a statement such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i] = 0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"items.clear()"),". Although ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," values are not directly mutable, they may refer to mutable values indirectly, so for this reason we consider them mutable too. Starlark values of these types are actually ",(0,i.kt)("em",{parentName:"p"},"references")," to variables."),(0,i.kt)("p",null,"Copying a reference to a variable, using an assignment statement for instance, creates an ",(0,i.kt)("em",{parentName:"p"},"alias")," for the variable, and the effects of operations applied to the variable through one alias are visible through all others."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'x = []                          # x refers to a new empty list variable\ny = x                           # y becomes an alias for x\nx.append(1)                     # changes the variable referred to by x\nprint(y)                        # "[1]"; y observes the mutation\n')),(0,i.kt)("p",null,"Starlark uses ",(0,i.kt)("em",{parentName:"p"},"call-by-value")," parameter passing: in a function call, argument values are assigned to function parameters as if by assignment statements. If the values are references, the caller and callee may refer to the same variables, so if the called function changes the variable referred to by a parameter, the effect may also be observed by the caller:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def f(y):\n    y.append(1)                 # changes the variable referred to by x\n\nx = []                          # x refers to a new empty list variable\nf(x)                            # f\'s parameter y becomes an alias for x\nprint(x)                        # "[1]"; x observes the mutation\n')),(0,i.kt)("p",null,"As in all imperative languages, understanding ",(0,i.kt)("em",{parentName:"p"},"aliasing"),", the relationship between reference values and the variables to which they refer, is crucial to writing correct programs."),(0,i.kt)("h2",{id:"freezing-a-value"},"Freezing a value"),(0,i.kt)("p",null,"Starlark has a feature unusual among imperative programming languages: a mutable value may be ",(0,i.kt)("em",{parentName:"p"},"frozen")," so that all subsequent attempts to mutate it fail with a dynamic error; the value, and all other values reachable from it, become ",(0,i.kt)("em",{parentName:"p"},"immutable"),"."),(0,i.kt)("p",null,"Immediately after execution of a Starlark module, all values in its top-level environment are frozen. Because all the global variables of an initialized Starlark module are immutable, the module may be published to and used by other threads in a parallel program without the need for locks. For example, the Bazel build system loads and executes BUILD and .bzl files in parallel, and two modules being executed concurrently may freely access variables or call functions from a third without the possibility of a race condition."),(0,i.kt)("h2",{id:"hashing"},"Hashing"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," data types are implemented using hash tables, so only ",(0,i.kt)("em",{parentName:"p"},"hashable")," values are suitable as keys of a ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," or elements of a ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),". Attempting to use a non-hashable value as the key in a hash table results in a dynamic error."),(0,i.kt)("p",null,"The hash of a value is an unspecified integer chosen so that two equal values have the same hash, in other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"x == y => hash(x) == hash(y)"),". A hashable value has the same hash throughout its lifetime."),(0,i.kt)("p",null,"Values of the types ",(0,i.kt)("inlineCode",{parentName:"p"},"NoneType"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", which are all immutable, are hashable."),(0,i.kt)("p",null,"Values of mutable types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," are not hashable. These values remain unhashable even if they have become immutable due to ",(0,i.kt)("em",{parentName:"p"},"freezing"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple")," value is hashable only if all its elements are hashable. Thus ",(0,i.kt)("inlineCode",{parentName:"p"},'("localhost", 80)')," is hashable but ",(0,i.kt)("inlineCode",{parentName:"p"},"([127, 0, 0, 1], 80)")," is not."),(0,i.kt)("p",null,"Values of the types ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"builtin_function_or_method")," are also hashable. Although functions are not necessarily immutable, as they may be closures that refer to mutable variables, instances of these types are compared by reference identity (see ",(0,i.kt)("a",{parentName:"p",href:"expressions#comparisons"},"Comparisons"),"), so their hash values are derived from their identity."),(0,i.kt)("h2",{id:"sequence-types"},"Sequence types"),(0,i.kt)("p",null,"Many Starlark data types represent a ",(0,i.kt)("em",{parentName:"p"},"sequence")," of values: lists, tuples, and sets are sequences of arbitrary values, and in many contexts dictionaries act like a sequence of their keys."),(0,i.kt)("p",null,"We can classify different kinds of sequence types based on the operations they support. Each is listed below using the name of its corresponding interface in the interpreter's Go API."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Iterable"),": an ",(0,i.kt)("em",{parentName:"li"},"iterable")," value lets us process each of its elements in a fixed order. Examples: ",(0,i.kt)("inlineCode",{parentName:"li"},"dict"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"set"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"tuple"),", but not ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Sequence"),": a ",(0,i.kt)("em",{parentName:"li"},"sequence of known length")," lets us know how many elements it contains without processing them. Examples: ",(0,i.kt)("inlineCode",{parentName:"li"},"dict"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"set"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"tuple"),", but not ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Indexable"),": an ",(0,i.kt)("em",{parentName:"li"},"indexed")," type has a fixed length and provides efficient random access to its elements, which are identified by integer indices. Examples: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"tuple"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"list"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SetIndexable"),": a ",(0,i.kt)("em",{parentName:"li"},"settable indexed type")," additionally allows us to modify the element at a given integer index. Example: ",(0,i.kt)("inlineCode",{parentName:"li"},"list"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Mapping"),": a mapping is an association of keys to values. Example: ",(0,i.kt)("inlineCode",{parentName:"li"},"dict"),".")),(0,i.kt)("p",null,"Although all of Starlark's core data types for sequences implement at least the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sequence")," contract, it's possible for an application that embeds the Starlark interpreter to define additional data types representing sequences of unknown length that implement only the ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable")," contract."),(0,i.kt)("p",null,"Strings are not iterable, though they do support the ",(0,i.kt)("inlineCode",{parentName:"p"},"len(s)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"s[i]")," operations. Starlark deviates from Python here to avoid a common pitfall in which a string is used by mistake where a list containing a single string was intended, resulting in its interpretation as a sequence of bytes."),(0,i.kt)("p",null,"Most Starlark operators and built-in functions that need a sequence of values will accept any iterable."),(0,i.kt)("p",null,"It is a dynamic error to mutate a sequence such as a list, set, or dictionary while iterating over it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def increment_values(dict):\n  for k in dict:\n    dict[k] += 1            # error: cannot insert into hash table during iteration\n\ndict = {"one": 1, "two": 2}\nincrement_values(dict)\n')),(0,i.kt)("h2",{id:"indexing"},"Indexing"),(0,i.kt)("p",null,"Many Starlark operators and functions require an index operand ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"list.insert(i, x)"),". Others require two indices ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," that indicate the start and end of a sub-sequence, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i:j]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list.index(x, i, j)"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"string.find(x, i, j)"),". All such operations follow similar conventions, described here."),(0,i.kt)("p",null,"Indexing in Starlark is ",(0,i.kt)("em",{parentName:"p"},"zero-based"),". The first element of a string or list has index 0, the next 1, and so on. The last element of a sequence of length ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," has index ",(0,i.kt)("inlineCode",{parentName:"p"},"n-1"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[0]          # "h"\n"hello"[4]          # "o"\n"hello"[5]          # error: index out of range\n')),(0,i.kt)("p",null,"For sub-sequence operations that require two indices, the first is ",(0,i.kt)("em",{parentName:"p"},"inclusive")," and the second ",(0,i.kt)("em",{parentName:"p"},"exclusive"),". Thus ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i:j]")," indicates the sequence starting with element ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," up to but not including element ",(0,i.kt)("inlineCode",{parentName:"p"},"j"),". The length of this sub-sequence is ",(0,i.kt)("inlineCode",{parentName:"p"},"j-i"),". This convention is known as ",(0,i.kt)("em",{parentName:"p"},"half-open indexing"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[1:4]            # "ell"\n')),(0,i.kt)("p",null,"Either or both of the index operands may be omitted. If omitted, the first is treated equivalent to 0 and the second is equivalent to the length of the sequence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[1:]                     # "ello"\n"hello"[:4]                     # "hell"\n')),(0,i.kt)("p",null,"It is permissible to supply a negative integer to an indexing operation. The effective index is computed from the supplied value by the following two-step procedure. First, if the value is negative, the length of the sequence is added to it. This provides a convenient way to address the final elements of the sequence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[-1]                     # "o",  like "hello"[4]\n"hello"[-3:-1]                  # "ll", like "hello"[2:4]\n')),(0,i.kt)("p",null,"Second, for sub-sequence operations, if the value is still negative, it is replaced by zero, or if it is greater than the length ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," of the sequence, it is replaced by ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),'. In effect, the index is "truncated" to the nearest value in the range ',(0,i.kt)("inlineCode",{parentName:"p"},"[0:n]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[-1000:+1000]        # "hello"\n')),(0,i.kt)("p",null,"This truncation step does not apply to indices of individual elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"hello"[-6]     # error: index out of range\n"hello"[-5]     # "h"\n"hello"[4]      # "o"\n"hello"[5]      # error: index out of range\n')))}d.isMDXComponent=!0}}]);