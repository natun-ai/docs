"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2112],{4907:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(9953);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(t),c=i,h=m["".concat(l,".").concat(c)]||m[c]||u[c]||r;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4903:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(1943),i=(t(9953),t(4907));const r={},o="Expressions",s={unversionedId:"reference/pyexp/pyexp-language-definition/expressions",id:"reference/pyexp/pyexp-language-definition/expressions",title:"Expressions",description:"An expression specifies the computation of a value.",source:"@site/docs/reference/pyexp/pyexp-language-definition/expressions.md",sourceDirName:"reference/pyexp/pyexp-language-definition",slug:"/reference/pyexp/pyexp-language-definition/expressions",permalink:"/docs/reference/pyexp/pyexp-language-definition/expressions",draft:!1,editUrl:"https://github.com/raptor-ml/docs/tree/master/docs/reference/pyexp/pyexp-language-definition/expressions.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Data types",permalink:"/docs/reference/pyexp/pyexp-language-definition/data-types"},next:{title:"Lexical elements",permalink:"/docs/reference/pyexp/pyexp-language-definition/lexical-elements"}},l={},p=[{value:"Identifiers",id:"identifiers",level:2},{value:"Literals",id:"literals",level:2},{value:"Parenthesized expressions",id:"parenthesized-expressions",level:2},{value:"Dictionary expressions",id:"dictionary-expressions",level:2},{value:"List expressions",id:"list-expressions",level:2},{value:"Unary operators",id:"unary-operators",level:2},{value:"Binary operators",id:"binary-operators",level:2},{value:"<code>or</code> and <code>and</code>",id:"or-and-and",level:3},{value:"Comparisons",id:"comparisons",level:3},{value:"Arithmetic operations",id:"arithmetic-operations",level:3},{value:"Membership tests",id:"membership-tests",level:3},{value:"String interpolation",id:"string-interpolation",level:3},{value:"Conditional expressions",id:"conditional-expressions",level:2},{value:"Comprehensions",id:"comprehensions",level:2},{value:"Function and method calls",id:"function-and-method-calls",level:2},{value:"Dot expressions",id:"dot-expressions",level:2},{value:"Index expressions",id:"index-expressions",level:2},{value:"Slice expressions",id:"slice-expressions",level:2},{value:"Lambda expressions",id:"lambda-expressions",level:2}],d={toc:p};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"expressions"},"Expressions"),(0,i.kt)("p",null,"An expression specifies the computation of a value."),(0,i.kt)("p",null,"The Starlark grammar defines several categories of expression. An ",(0,i.kt)("em",{parentName:"p"},"operand")," is an expression consisting of a single token (such as an identifier or a literal), or a bracketed expression. Operands are self-delimiting. An operand may be followed by any number of dot, call, or slice suffixes, to form a ",(0,i.kt)("em",{parentName:"p"},"primary")," expression. In some places in the Starlark grammar where an expression is expected, it is legal to provide a comma-separated list of expressions denoting a tuple. The grammar uses ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression")," where a multiple-component expression is allowed, and ",(0,i.kt)("inlineCode",{parentName:"p"},"Test")," where it accepts an expression of only a single component."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Expression = Test {',' Test} .\n\nTest = LambdaExpr | IfExpr | PrimaryExpr | UnaryExpr | BinaryExpr .\n\nPrimaryExpr = Operand\n            | PrimaryExpr DotSuffix\n            | PrimaryExpr CallSuffix\n            | PrimaryExpr SliceSuffix\n            .\n\nOperand = identifier\n        | int | float | string\n        | ListExpr | ListComp\n        | DictExpr | DictComp\n        | '(' [Expression] [,] ')'\n        | ('-' | '+') PrimaryExpr\n        .\n\nDotSuffix   = '.' identifier .\nCallSuffix  = '(' [Arguments [',']] ')' .\nSliceSuffix = '[' [Expression] [':' Test [':' Test]] ']' .\n")),(0,i.kt)("p",null,"TODO: resolve position of +x, -x, and 'not x' in grammar: Operand or UnaryExpr?"),(0,i.kt)("h2",{id:"identifiers"},"Identifiers"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Primary = identifier\n")),(0,i.kt)("p",null,"An identifier is a name that identifies a value."),(0,i.kt)("p",null,"Lookup of locals and globals may fail if not yet defined."),(0,i.kt)("h2",{id:"literals"},"Literals"),(0,i.kt)("p",null,"Starlark supports literals of three different kinds:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Primary = int | float | string\n")),(0,i.kt)("p",null,"Evaluation of a literal yields a value of the given type (string, int, or float) with the given value. See ",(0,i.kt)("a",{parentName:"p",href:"expressions#literals"},"Literals")," for details."),(0,i.kt)("h2",{id:"parenthesized-expressions"},"Parenthesized expressions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Primary = '(' [Expression] ')'\n")),(0,i.kt)("p",null,"A single expression enclosed in parentheses yields the result of that expression. Explicit parentheses may be used for clarity, or to override the default association of subexpressions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"1 + 2 * 3 + 4                   # 11\n(1 + 2) * (3 + 4)               # 21\n")),(0,i.kt)("p",null,"If the parentheses are empty, or contain a single expression followed by a comma, or contain two or more expressions, the expression yields a tuple."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"()                              # (), the empty tuple\n(1,)                            # (1,), a tuple of length 1\n(1, 2)                          # (1, 2), a 2-tuple or pair\n(1, 2, 3)                       # (1, 2, 3), a 3-tuple or triple\n")),(0,i.kt)("p",null,"In some contexts, such as a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," or assignment statement or the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," statement, a tuple may be expressed without parentheses."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x, y = 1, 2\n\nreturn 1, 2\n\nfor x in 1, 2:\n   print(x)\n")),(0,i.kt)("p",null,"Starlark (like Python 3) does not accept an unparenthesized tuple expression as the operand of a list comprehension:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[2*x for x in 1, 2, 3]          # parse error: unexpected ','\n")),(0,i.kt)("h2",{id:"dictionary-expressions"},"Dictionary expressions"),(0,i.kt)("p",null,"A dictionary expression is a comma-separated list of colon-separated key/value expression pairs, enclosed in curly brackets, and it yields a new dictionary object. An optional comma may follow the final pair."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"DictExpr = '{' [Entries [',']] '}' .\nEntries  = Entry {',' Entry} .\nEntry    = Test ':' Test .\n")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'{}\n{"one": 1}\n{"one": 1, "two": 2,}\n')),(0,i.kt)("p",null,"The key and value expressions are evaluated in left-to-right order. Evaluation fails if the same key is used multiple times."),(0,i.kt)("p",null,"Only ",(0,i.kt)("a",{parentName:"p",href:"value-concepts#hashing"},"hashable")," values may be used as the keys of a dictionary. This includes all built-in types except dictionaries, sets, and lists; a tuple is hashable only if its elements are hashable."),(0,i.kt)("h2",{id:"list-expressions"},"List expressions"),(0,i.kt)("p",null,"A list expression is a comma-separated list of element expressions, enclosed in square brackets, and it yields a new list object. An optional comma may follow the last element expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ListExpr = '[' [Expression [',']] ']' .\n")),(0,i.kt)("p",null,"Element expressions are evaluated in left-to-right order."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[]                      # [], empty list\n[1]                     # [1], a 1-element list\n[1, 2, 3,]              # [1, 2, 3], a 3-element list\n")),(0,i.kt)("h2",{id:"unary-operators"},"Unary operators"),(0,i.kt)("p",null,"There are three unary operators, all appearing before their operand: ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"~"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"not"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"UnaryExpr = '+' PrimaryExpr\n          | '-' PrimaryExpr\n          | '~' PrimaryExpr\n          | 'not' Test\n          .\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"+ number        unary positive          (int, float)\n- number        unary negation          (int, float)\n~ number        unary bitwise inversion (int)\nnot x           logical negation        (any type)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," operators may be applied to any number (",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),") and return the number unchanged. Unary ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," is never necessary in a correct program, but may serve as an assertion that its operand is a number, or as documentation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"if x > 0:\n    return +1\nelse if x < 0:\n    return -1\nelse:\n    return 0\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," operator returns the negation of the truth value of its operand."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'not True                        # False\nnot False                       # True\nnot [1, 2, 3]                   # False\nnot ""                          # True\nnot 0                           # True\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"~")," operator yields the bitwise inversion of its integer argument. The bitwise inversion of x is defined as -(x+1)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"~1                              # -2\n~-1                             # 0\n~0                              # -1\n")),(0,i.kt)("h2",{id:"binary-operators"},"Binary operators"),(0,i.kt)("p",null,"Starlark has the following binary operators, arranged in order of increasing precedence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"or\nand\n==   !=   <    >   <=   >=   in   not in\n|\n^\n&\n<<   >>\n-    +\n*    /    //   %\n")),(0,i.kt)("p",null,"Comparison operators, ",(0,i.kt)("inlineCode",{parentName:"p"},"in"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"not in")," are non-associative, so the parser will not accept ",(0,i.kt)("inlineCode",{parentName:"p"},"0 <= i < n"),". All other binary operators of equal precedence associate to the left."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"BinaryExpr = Test {Binop Test} .\n\nBinop = 'or'\n      | 'and'\n      | '==' | '!=' | '<' | '>' | '<=' | '>=' | 'in' | 'not' 'in'\n      | '|'\n      | '^'\n      | '&'\n      | '-' | '+'\n      | '*' | '%' | '/' | '//'\n      | '<<' | '>>'\n      .\n")),(0,i.kt)("h3",{id:"or-and-and"},(0,i.kt)("inlineCode",{parentName:"h3"},"or")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"and")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," operators yield, respectively, the logical disjunction and conjunction of their arguments, which need not be Booleans. The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"x or y")," yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," if its truth value is ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", or the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'False or False      # False\nFalse or True       # True\nTrue  or False      # True\nTrue  or True       # True\n\n0 or "hello"        # "hello"\n1 or "hello"        # 1\n')),(0,i.kt)("p",null,"Similarly, ",(0,i.kt)("inlineCode",{parentName:"p"},"x and y")," yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," if its truth value is ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", or the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'False and False     # False\nFalse and True      # False\nTrue  and False     # False\nTrue  and True      # True\n\n0 and "hello"       # 0\n1 and "hello"       # "hello"\n')),(0,i.kt)("p",null,'These operators use "short circuit" evaluation, so the second expression is not evaluated if the value of the first expression has already determined the result, allowing constructions like these:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'len(x) > 0 and x[0] == 1        # x[0] is not evaluated if x is empty\nx and x[0] == 1\nlen(x) == 0 or x[0] == ""\nnot x or not x[0]\n')),(0,i.kt)("h3",{id:"comparisons"},"Comparisons"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," operator reports whether its operands are equal; the ",(0,i.kt)("inlineCode",{parentName:"p"},"!=")," operator is its negation."),(0,i.kt)("p",null,"The operators ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},">"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", and ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," perform an ordered comparison of their operands. It is an error to apply these operators to operands of unequal type, unless one of the operands is an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and the other is a ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),". Of the built-in types, only the following support ordered comparison, using the ordering relation shown:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"NoneType        # None <= None\nbool            # False < True\nint             # mathematical\nfloat           # as defined by IEEE 754\nstring          # lexicographical\ntuple           # lexicographical\nlist            # lexicographical\n")),(0,i.kt)("p",null,"Comparison of floating point values follows the IEEE 754 standard, which breaks several mathematical identities. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"NaN")," value, the comparisons ",(0,i.kt)("inlineCode",{parentName:"p"},"x < y"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x == y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"x > y")," all yield false for all values of ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("p",null,"Applications may define additional types that support ordered comparison."),(0,i.kt)("p",null,"The remaining built-in types support only equality comparisons. Values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," compare equal if their elements compare equal, and values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"builtin_function_or_method")," are equal only to themselves."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"dict                            # equal contents\nset                             # equal contents\nfunction                        # identity\nbuiltin_function_or_method      # identity\n")),(0,i.kt)("h3",{id:"arithmetic-operations"},"Arithmetic operations"),(0,i.kt)("p",null,"The following table summarizes the binary arithmetic operations available for built-in types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"Arithmetic (int or float; result has type float unless both operands have type int)\n   number + number              # addition\n   number - number              # subtraction\n   number * number              # multiplication\n   number / number              # real division  (result is always a float)\n   number // number             # floored division\n   number % number              # remainder of floored division\n   number ^ number              # bitwise XOR\n   number << number             # bitwise left shift\n   number >> number             # bitwise right shift\n\nConcatenation\n   string + string\n     list + list\n    tuple + tuple\n\nRepetition (string/list/tuple)\n      int * sequence\n sequence * int\n\nString interpolation\n   string % any                 # see String Interpolation\n\nSets\n      int | int                 # bitwise union (OR)\n      set | set                 # set union\n      int & int                 # bitwise intersection (AND)\n      set & set                 # set intersection\n      set ^ set                 # set symmetric difference\n")),(0,i.kt)("p",null,"The operands of the arithmetic operators ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"//"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," must both be numbers (",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),") but need not have the same type. The type of the result has type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," only if both operands have that type. The result of real division ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," always has type ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator may be applied to non-numeric operands of the same type, such as two lists, two tuples, or two strings, in which case it computes the concatenation of the two operands and yields a new value of the same type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"Hello, " + "world"     # "Hello, world"\n(1, 2) + (3, 4)         # (1, 2, 3, 4)\n[1, 2] + [3, 4]         # [1, 2, 3, 4]\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator may be applied to an integer ",(0,i.kt)("em",{parentName:"p"},"n")," and a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple"),", in which case it yields a new value of the same sequence type consisting of ",(0,i.kt)("em",{parentName:"p"},"n")," repetitions of the original sequence. The order of the operands is immaterial. Negative values of ",(0,i.kt)("em",{parentName:"p"},"n")," behave like zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"'mur' * 2               # 'murmur'\n3 * range(3)            # [0, 1, 2, 0, 1, 2, 0, 1, 2]\n")),(0,i.kt)("p",null,"Applications may define additional types that support any subset of these operators."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operator requires two operands of the same type, either ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),". For integers, it yields the bitwise intersection (AND) of its operands. For sets, it yields a new set containing the intersection of the elements of the operand sets, preserving the element order of the left operand."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," operator likewise computes bitwise or set unions. The result of ",(0,i.kt)("inlineCode",{parentName:"p"},"set | set")," is a new set whose elements are the union of the operands, preserving the order of the elements of the operands, left before right."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," operator accepts operands of either ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," type. For integers, it yields the bitwise XOR (exclusive OR) of its operands. For sets, it yields a new set containing elements of either first or second operand but not both (symmetric difference)."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<<")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," operators require operands of ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type both. They shift the first operand to the left or right by the number of bits given by the second operand. It is a dynamic error if the second operand is negative. Implementations may impose a limit on the second operand of a left shift."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"0x12345678 & 0xFF               # 0x00000078\n0x12345678 | 0xFF               # 0x123456FF\n0b01011101 ^ 0b110101101        # 0b111110000\n0b01011101 >> 2                 # 0b010111\n0b01011101 << 2                 # 0b0101110100\n\nset([1, 2]) & set([2, 3])       # set([2])\nset([1, 2]) | set([2, 3])       # set([1, 2, 3])\nset([1, 2]) ^ set([2, 3])       # set([1, 3])\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The Go implementation of Starlark requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"-set")," flag to enable support for sets. The Java implementation does not support sets."),(0,i.kt)("h3",{id:"membership-tests"},"Membership tests"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      any in     sequence       (list, tuple, dict, set, string)\n      any not in sequence\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," operator reports whether its first operand is a member of its second operand, which must be a list, tuple, dict, set, or string. The ",(0,i.kt)("inlineCode",{parentName:"p"},"not in")," operator is its negation. Both return a Boolean."),(0,i.kt)("p",null,"The meaning of membership varies by the type of the second operand: the members of a list, tuple, or set are its elements; the members of a dict are its keys; the members of a string are all its substrings."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'1 in [1, 2, 3]                  # True\n4 in (1, 2, 3)                  # False\n4 not in set([1, 2, 3])         # True\n\nd = {"one": 1, "two": 2}\n"one" in d                      # True\n"three" in d                    # False\n1 in d                          # False\n[] in d             # False\n\n"nasty" in "dynasty"            # True\n"a" in "banana"                 # True\n"f" not in "way"                # True\n')),(0,i.kt)("h3",{id:"string-interpolation"},"String interpolation"),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"format % args")," performs ",(0,i.kt)("em",{parentName:"p"},"string interpolation"),", a simple form of template expansion. The ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," string is interpreted as a sequence of literal portions and ",(0,i.kt)("em",{parentName:"p"},"conversions"),". Each conversion, which starts with a ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," character, is replaced by its corresponding value from ",(0,i.kt)("inlineCode",{parentName:"p"},"args"),". The characters following ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," in each conversion determine which argument it uses and how to convert it to a string."),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," character marks the start of a conversion specifier, unless it is immediately followed by another ",(0,i.kt)("inlineCode",{parentName:"p"},"%"),", in which case both characters together denote a literal percent sign."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},'"%"')," is immediately followed by ",(0,i.kt)("inlineCode",{parentName:"p"},'"(key)"'),", the parenthesized substring specifies the key of the ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," dictionary whose corresponding value is the operand to convert. Otherwise, the conversion's operand is the next element of ",(0,i.kt)("inlineCode",{parentName:"p"},"args"),", which must be a tuple with exactly one component per conversion, unless the format string contains only a single conversion, in which case ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," itself is its operand."),(0,i.kt)("p",null,"Starlark does not support the flag, width, and padding specifiers supported by Python's ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," and other variants of C's ",(0,i.kt)("inlineCode",{parentName:"p"},"printf"),"."),(0,i.kt)("p",null,"After the optional ",(0,i.kt)("inlineCode",{parentName:"p"},"(key)")," comes a single letter indicating what operand types are valid and how to convert the operand ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," to a string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"%       none            literal percent sign\ns       any             as if by str(x)\nr       any             as if by repr(x)\nd       number          signed integer decimal\ni       number          signed integer decimal\no       number          signed octal\nx       number          signed hexadecimal, lowercase\nX       number          signed hexadecimal, uppercase\ne       number          float exponential format, lowercase\nE       number          float exponential format, uppercase\nf       number          float decimal format, lowercase\nF       number          float decimal format, uppercase\ng       number          like %e for large exponents, %f otherwise\nG       number          like %E for large exponents, %F otherwise\nc       string          x (string must encode a single Unicode code point)\n        int             as if by chr(x)\n")),(0,i.kt)("p",null,"It is an error if the argument does not have the type required by the conversion specifier. A Boolean argument is not considered a number."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"Hello %s, your score is %d" % ("Bob", 75)      # "Hello Bob, your score is 75"\n\n"%d %o %x %c" % (65, 65, 65, 65)                # "65 101 41 A" (decimal, octal, hexadecimal, Unicode)\n\n"%(greeting)s, %(audience)s" % dict(            # "Hello, world"\n  greeting="Hello",\n  audience="world",\n)\n\n"rate = %g%% APR" % 3.5                         # "rate = 3.5% APR"\n')),(0,i.kt)("p",null,"One subtlety: to use a tuple as the operand of a conversion in format string containing only a single conversion, you must wrap the tuple in a singleton tuple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"coordinates=%s" % (40.741491, -74.003680)  # error: too many arguments for format string\n"coordinates=%s" % ((40.741491, -74.003680),)   # "coordinates=(40.741491, -74.003680)"\n')),(0,i.kt)("p",null,"TODO: specify ",(0,i.kt)("inlineCode",{parentName:"p"},"%e")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"%f")," more precisely."),(0,i.kt)("h2",{id:"conditional-expressions"},"Conditional expressions"),(0,i.kt)("p",null,"A conditional expression has the form ",(0,i.kt)("inlineCode",{parentName:"p"},"a if cond else b"),". It first evaluates the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond"),". If it's true, it evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and yields its value; otherwise it yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"IfExpr = Test 'if' Test 'else' Test .\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"yes" if enabled else "no"\n')),(0,i.kt)("h2",{id:"comprehensions"},"Comprehensions"),(0,i.kt)("p",null,"A comprehension constructs new list or dictionary value by looping over one or more iterables and evaluating a ",(0,i.kt)("em",{parentName:"p"},"body")," expression that produces successive elements of the result."),(0,i.kt)("p",null,"A list comprehension consists of a single expression followed by one or more ",(0,i.kt)("em",{parentName:"p"},"clauses"),", the first of which must be a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," clause. Each ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," clause resembles a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," statement, and specifies an iterable operand and a set of variables to be assigned by successive values of the iterable. An ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," cause resembles an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement, and specifies a condition that must be met for the body expression to be evaluated. A sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," clauses acts like a nested sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ListComp = '[' Test {CompClause} ']'.\nDictComp = '{' Entry {CompClause} '}' .\n\nCompClause = 'for' LoopVariables 'in' Test\n           | 'if' Test .\n\nLoopVariables = PrimaryExpr {',' PrimaryExpr} .\n")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[x*x for x in range(5)]                 # [0, 1, 4, 9, 16]\n[x*x for x in range(5) if x%2 == 0]     # [0, 4, 16]\n[(x, y) for x in range(5)\n        if x%2 == 0\n        for y in range(5)\n        if y > x]                       # [(0, 1), (0, 2), (0, 3), (0, 4), (2, 3), (2, 4)]\n")),(0,i.kt)("p",null,"A dict comprehension resembles a list comprehension, but its body is a pair of expressions, ",(0,i.kt)("inlineCode",{parentName:"p"},"key: value"),", separated by a colon, and its result is a dictionary containing the key/value pairs for which the body expression was evaluated. Evaluation fails if the value of any key is unhashable."),(0,i.kt)("p",null,"As with a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop, the loop variables may exploit compound assignment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'[x*y+z for (x, y), z in [((2, 3), 5), (("o", 2), "!")]]         # [11, \'oo!\']\n')),(0,i.kt)("p",null,"Starlark, following Python 3, does not accept an unparenthesized tuple or lambda expression as the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," clause:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[x*x for x in 1, 2, 3]      # parse error: unexpected comma\n[x*x for x in lambda: 0]    # parse error: unexpected lambda\n")),(0,i.kt)("p",null,"Comprehensions in Starlark, again following Python 3, define a new lexical block, so assignments to loop variables have no effect on variables of the same name in an enclosing block:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = 1\n_ = [x for x in [2]]            # new variable x is local to the comprehension\nprint(x)                        # 1\n")),(0,i.kt)("p",null,"The operand of a comprehension's first clause (always a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),") is resolved in the lexical block enclosing the comprehension. In the examples below, identifiers referring to the outer variable named ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," have been distinguished by subscript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x\u2080 = (1, 2, 3)\n[x*x for x in x\u2080]               # [1, 4, 9]\n[x*x for x in x\u2080 if x%2 == 0]   # [4]\n")),(0,i.kt)("p",null,"All subsequent ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expressions are resolved within the comprehension's lexical block, as in this rather obscure example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x\u2080 = ([1, 2], [3, 4], [5, 6])\n[x*x for x in x\u2080 for x in x if x%2 == 0]     # [4, 16, 36]\n")),(0,i.kt)("p",null,"which would be more clearly rewritten as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = ([1, 2], [3, 4], [5, 6])\n[z*z for y in x for z in y if z%2 == 0]     # [4, 16, 36]\n")),(0,i.kt)("h2",{id:"function-and-method-calls"},"Function and method calls"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"CallSuffix = '(' [Arguments [',']] ')' .\n\nArguments = Argument {',' Argument} .\nArgument  = Test | identifier '=' Test | '*' Test | '**' Test .\n")),(0,i.kt)("p",null,"A value ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"builtin_function_or_method")," may be called using the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"f(...)"),". Applications may define additional types whose values may be called in the same way."),(0,i.kt)("p",null,"A method call such as ",(0,i.kt)("inlineCode",{parentName:"p"},'filename.endswith(".star")')," is the composition of two operations, ",(0,i.kt)("inlineCode",{parentName:"p"},"m = filename.endswith")," and ",(0,i.kt)("inlineCode",{parentName:"p"},'m(".star")'),". The first, a dot operation, yields a ",(0,i.kt)("em",{parentName:"p"},"bound method"),", a function value that pairs a receiver value (the ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," string) with a choice of method (",(0,i.kt)("a",{parentName:"p",href:"built-in-methods#stringendswith"},"string\xb7endswith"),")."),(0,i.kt)("p",null,"Only built-in or application-defined types may have methods."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"data-types#functions"},"Functions")," for an explanation of function parameter passing."),(0,i.kt)("h2",{id:"dot-expressions"},"Dot expressions"),(0,i.kt)("p",null,"A dot expression ",(0,i.kt)("inlineCode",{parentName:"p"},"x.f")," selects the attribute ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," (a field or method) of the value ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,i.kt)("p",null,"Fields are possessed by none of the main Starlark ",(0,i.kt)("a",{parentName:"p",href:"data-types"},"data types"),", but some application-defined types have them. Methods belong to the built-in types ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),", and to many application-defined types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"DotSuffix = '.' identifier .\n")),(0,i.kt)("p",null,"A dot expression fails if the value does not have an attribute of the specified name."),(0,i.kt)("p",null,"Use the built-in function ",(0,i.kt)("inlineCode",{parentName:"p"},'hasattr(x, "f")')," to ascertain whether a value has a specific attribute, or ",(0,i.kt)("inlineCode",{parentName:"p"},"dir(x)")," to enumerate all its attributes. The ",(0,i.kt)("inlineCode",{parentName:"p"},'getattr(x, "f")')," function can be used to select an attribute when the name ",(0,i.kt)("inlineCode",{parentName:"p"},'"f"')," is not known statically."),(0,i.kt)("p",null,"A dot expression that selects a method typically appears within a call expression, as in these examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'["able", "baker", "charlie"].index("baker")     # 1\n"banana".count("a")                             # 3\n"banana".reverse()                              # error: string has no .reverse field or method\n')),(0,i.kt)("p",null,"But when not called immediately, the dot expression evaluates to a ",(0,i.kt)("em",{parentName:"p"},"bound method"),", that is, a method coupled to a specific receiver value. A bound method can be called like an ordinary function, without a receiver argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'f = "banana".count\nf                                               # <built-in method count of string value>\nf("a")                                          # 3\nf("n")                                          # 2\n')),(0,i.kt)("h2",{id:"index-expressions"},"Index expressions"),(0,i.kt)("p",null,"An index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," yields the ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),"th element of an ",(0,i.kt)("em",{parentName:"p"},"indexable")," type such as a string, tuple, or list. The index ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," must be an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," value in the range -",(0,i.kt)("inlineCode",{parentName:"p"},"n")," \u2264 ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," < ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"len(a)"),"; any other index results in an error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SliceSuffix = '[' [Expression] [':' Test [':' Test]] ']' .\n")),(0,i.kt)("p",null,"A valid negative index ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," behaves like the non-negative index ",(0,i.kt)("inlineCode",{parentName:"p"},"n+i"),", allowing for convenient indexing relative to the end of the sequence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"abc"[0]                        # "a"\n"abc"[1]                        # "b"\n"abc"[-1]                       # "c"\n\n("zero", "one", "two")[0]       # "zero"\n("zero", "one", "two")[1]       # "one"\n("zero", "one", "two")[-1]      # "two"\n')),(0,i.kt)("p",null,"An index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"d[key]")," may also be applied to a dictionary ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", to obtain the value associated with the specified key. It is an error if the dictionary contains no such key."),(0,i.kt)("p",null,"An index expression appearing on the left side of an assignment causes the specified list or dictionary element to be updated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'a = range(3)            # a == [0, 1, 2]\na[2] = 7                # a == [0, 1, 7]\n\ncoins["suzie b"] = 100\n')),(0,i.kt)("p",null,"It is a dynamic error to attempt to update an element of an immutable type, such as a tuple or string, or a frozen value of a mutable type."),(0,i.kt)("h2",{id:"slice-expressions"},"Slice expressions"),(0,i.kt)("p",null,"A slice expression ",(0,i.kt)("inlineCode",{parentName:"p"},"a[start:stop:stride]")," yields a new value containing a sub-sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", which must be a string, tuple, or list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SliceSuffix = '[' [Expression] [':' Test [':' Test]] ']' .\n")),(0,i.kt)("p",null,"Each of the ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"stop"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," operands is optional; if present, and not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", each must be an integer. The ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," value defaults to 1. If the stride is not specified, the colon preceding it may be omitted too. It is an error to specify a stride of zero."),(0,i.kt)("p",null,"Conceptually, these operands specify a sequence of values ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," starting at ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and successively adding ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," until ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," reaches or passes ",(0,i.kt)("inlineCode",{parentName:"p"},"stop"),". The result consists of the concatenation of values of ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," for which ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is valid.","`"),(0,i.kt)("p",null,"The effective start and stop indices are computed from the three operands as follows. Let ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," be the length of the sequence."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If the stride is positive:")," If the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," operand was omitted, it defaults to -infinity. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," operand was omitted, it defaults to +infinity. For either operand, if a negative value was supplied, ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is added to it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),' values are then "clamped" to the nearest value in the range 0 to ',(0,i.kt)("inlineCode",{parentName:"p"},"n"),", inclusive."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If the stride is negative:")," If the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," operand was omitted, it defaults to +infinity. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," operand was omitted, it defaults to -infinity. For either operand, if a negative value was supplied, ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is added to it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),' values are then "clamped" to the nearest value in the range -1 to ',(0,i.kt)("inlineCode",{parentName:"p"},"n"),"-1, inclusive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"abc"[1:]               # "bc"  (remove first element)\n"abc"[:-1]              # "ab"  (remove last element)\n"abc"[1:-1]             # "b"   (remove first and last element)\n"banana"[1::2]          # "aaa" (select alternate elements starting at index 1)\n"banana"[4::-2]         # "nnb" (select alternate elements in reverse, starting at index 4)\n')),(0,i.kt)("p",null,"Unlike Python, Starlark does not allow a slice expression on the left side of an assignment."),(0,i.kt)("p",null,"Slicing a tuple or string may be more efficient than slicing a list because tuples and strings are immutable, so the result of the operation can share the underlying representation of the original operand (when the stride is 1). By contrast, slicing a list requires the creation of a new list and copying of the necessary elements."),(0,i.kt)("h2",{id:"lambda-expressions"},"Lambda expressions"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expression yields a new function value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"LambdaExpr = 'lambda' [Parameters] ':' Test .\n\nParameters = Parameter {',' Parameter} .\nParameter  = identifier\n           | identifier '=' Test\n           | '*'\n           | '*' identifier\n           | '**' identifier\n           .\n")),(0,i.kt)("p",null,"Syntactically, a lambda expression consists of the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda"),", followed by a parameter list like that of a ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statement but unparenthesized, then a colon ",(0,i.kt)("inlineCode",{parentName:"p"},":"),", and a single expression, the ",(0,i.kt)("em",{parentName:"p"},"function body"),"."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def map(f, list):\n    return [f(x) for x in list]\n\nmap(lambda x: 2*x, range(3))    # [2, 4, 6]\n")),(0,i.kt)("p",null,"As with functions created by a ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statement, a lambda function captures the syntax of its body, the default values of any optional parameters, the value of each free variable appearing in its body, and the global dictionary of the current module."),(0,i.kt)("p",null,"The name of a function created by a lambda expression is ",(0,i.kt)("inlineCode",{parentName:"p"},'"lambda"'),"."),(0,i.kt)("p",null,"The two statements below are essentially equivalent, but the function created by the ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statement is named ",(0,i.kt)("inlineCode",{parentName:"p"},"twice")," and the function created by the lambda expression is named ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def twice(x):\n   return x * 2\n\ntwice = lambda x: x * 2\n")))}m.isMDXComponent=!0}}]);