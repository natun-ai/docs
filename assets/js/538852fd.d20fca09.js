"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3264],{4907:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(9953);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,k=m["".concat(s,".").concat(c)]||m[c]||d[c]||l;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(1943),r=(n(9953),n(4907));const l={sidebar_label:"decorators",title:"decorators"},i=void 0,o={unversionedId:"reference/labsdk/reference/decorators",id:"reference/labsdk/reference/decorators",title:"decorators",description:"The LabSDK provides a set of decorators that can be used to configure the assets in a way that can be translated to an",source:"@site/docs/reference/labsdk/reference/decorators.md",sourceDirName:"reference/labsdk/reference",slug:"/reference/labsdk/reference/decorators",permalink:"/reference/labsdk/reference/decorators",draft:!1,editUrl:"https://github.com/raptor-ml/docs/tree/master/docs/reference/labsdk/reference/decorators.md",tags:[],version:"current",frontMatter:{sidebar_label:"decorators",title:"decorators"},sidebar:"reference",previous:{title:"Exporting to production",permalink:"/reference/labsdk/export"},next:{title:"local_state",permalink:"/reference/labsdk/reference/local_state"}},s={},p=[{value:"namespace",id:"namespace",level:4},{value:"runtime",id:"runtime",level:4},{value:"freshness",id:"freshness",level:4},{value:"labels",id:"labels",level:4},{value:"data_source",id:"data_source",level:4},{value:"aggregation",id:"aggregation",level:4},{value:"keep_previous",id:"keep_previous",level:4},{value:"feature",id:"feature",level:4},{value:"model",id:"model",level:4}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The LabSDK provides a set of decorators that can be used to configure the assets in a way that can be translated to an\noptimized production-ready solution by Raptor."),(0,r.kt)("h4",{id:"namespace"},"namespace"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def namespace(namespace: str)\n")),(0,r.kt)("p",null,"Register a namespace for the asset."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"namespace"),": namespace name")),(0,r.kt)("h4",{id:"runtime"},"runtime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def runtime(packages: Optional[List[str]], env_name: Optional[str])\n")),(0,r.kt)("p",null,"Register the runtime environment for the asset."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"packages"),": "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"env_name"),": ")),(0,r.kt)("h4",{id:"freshness"},"freshness"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def freshness(max_age: Union[str, timedelta],\n              max_stale: Optional[Union[str, timedelta]] = None,\n              timeout: Optional[Union[str, timedelta]] = timedelta(seconds=1))\n")),(0,r.kt)("p",null,"Set the freshness policy, and timeout of a feature or model."),(0,r.kt)("p",null,"Must be used in conjunction with a feature or model decorator.\nIs placed AFTER the @model or @feature decorator."),(0,r.kt)("p",null,"Feature or Model values are considered fresh if they are younger than the ",(0,r.kt)("inlineCode",{parentName:"p"},"max_age"),".\nIf the value is older than ",(0,r.kt)("inlineCode",{parentName:"p"},"max_age"),", we","'","ll try to recompute it with a timeout of ",(0,r.kt)("inlineCode",{parentName:"p"},"timeout"),".\nIf we fail to recompute the value within ",(0,r.kt)("inlineCode",{parentName:"p"},"timeout"),", we","'","ll return the stale value as long as it is younger than\n",(0,r.kt)("inlineCode",{parentName:"p"},"max_stale"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_age")," (",(0,r.kt)("inlineCode",{parentName:"li"},"timedelta or str of the form &#x27;2h 3m 4s&#x27;"),"): the target freshness of the feature or model."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_stale")," (",(0,r.kt)("inlineCode",{parentName:"li"},"timedelta or str of the form &#x27;2h 3m 4s&#x27;"),"): the time after which the feature or model is considered stale. defaults to == max_age"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timeout")," (",(0,r.kt)("inlineCode",{parentName:"li"},"timedelta or str of the form &#x27;2h 3m 4s&#x27;"),"): the maximum time allowed for the feature to be computed. defaults to 1 second.")),(0,r.kt)("h4",{id:"labels"},"labels"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def labels(labels: Dict[str, str])\n")),(0,r.kt)("p",null,"Register labels for the asset."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"labels"),": a dictionary of tags.")),(0,r.kt)("h4",{id:"data_source"},"data","_","source"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def data_source(training_data: DataFrame,\n                keys: Optional[Union[str, List[str]]] = None,\n                name: Optional[str] = None,\n                timestamp: Optional[str] = None,\n                production_config: Optional[SourceProductionConfig] = None)\n")),(0,r.kt)("p",null,"Register a DataSource for the Feature Definition."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"training_data"),": DataFrame of training data. This should reflect the schema of the data source in production."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keys"),": list of columns that are keys."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": name of the data source. Defaults to the class name."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp"),": name of the timestamp column. If not specified, the timestamp is inferred from the training data.")),(0,r.kt)("h4",{id:"aggregation"},"aggregation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def aggregation(function: Union[AggregationFunction, List[AggregationFunction],\n                                str, List[str]], over: Union[str, timedelta,\n                                                             None],\n                granularity: Union[str, timedelta, None])\n")),(0,r.kt)("p",null,"Register aggregations for the Feature Definition."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"function")," (",(0,r.kt)("inlineCode",{parentName:"li"},"AggregationFunction or List[AggregationFunction] or str or List[str]"),"): a list of :func:",(0,r.kt)("inlineCode",{parentName:"li"},"AggrFn"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"over")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or timedelta in the form &#x27;2h 3m 4s&#x27;"),"): the time period over which to aggregate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"granularity")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or timedelta in the form &#x27;2h 3m 4s&#x27;"),"): the granularity of the aggregation (this is overriding the freshness).")),(0,r.kt)("h4",{id:"keep_previous"},"keep","_","previous"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def keep_previous(versions: int, over: Union[str, timedelta])\n")),(0,r.kt)("p",null,"Keep previous versions of the feature."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"versions")," (",(0,r.kt)("inlineCode",{parentName:"li"},"int"),"): the number of versions to keep (excluding the current value)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"over")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or timedelta in the form &#x27;2h 3m 4s&#x27;"),"): the maximum time period to keep a previous values in the history since the last update. You can specify\n",(0,r.kt)("inlineCode",{parentName:"li"},"0")," to keep the value until the next update.\nversion is computed.")),(0,r.kt)("h4",{id:"feature"},"feature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def feature(keys: Union[str, List[str]],\n            name: Optional[str] = None,\n            data_source: Optional[Union[str, object]] = None,\n            sourceless_markers_df: Optional[DataFrame] = None)\n")),(0,r.kt)("p",null,"Register a Feature Definition within the LabSDK."),(0,r.kt)("p",null,"A feature definition is a Python handler function that process a calculation request and calculates"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keys"),": a list of indexing keys, indicated the owner of the feature value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": the name of the feature. If not provided, the function name will be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data_source"),": the (fully qualified) name of the DataSource."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sourceless_markers_df"),": a DataFrame with the timestamp and keys markers for training sourceless features. It\na timestamp column, and a column for each key.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"a registered Feature Definition"),(0,r.kt)("h4",{id:"model"},"model"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def model(keys: Union[str, List[str]],\n          input_features: Union[str, List[str], Callable, List[Callable]],\n          input_labels: Union[str, List[str], Callable, List[Callable]],\n          model_framework: Union[ModelFramework, str],\n          model_server: Optional[Union[ModelServer, str]] = None,\n          key_feature: Optional[Union[str, Callable]] = None,\n          prediction_output_schema: Optional[TypedDict] = None,\n          name: Optional[str] = None)\n")),(0,r.kt)("p",null,"Register a Model Definition within the LabSDK."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keys")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or list of str"),"): the keys of the model. The keys are required for fetching the features."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_features")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or list of str or callable or list of callable"),"): the features that are used as input to the model."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_labels")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or list of str or callable or list of callable"),"): the labels that are used as input to the model."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"model_framework")," (",(0,r.kt)("inlineCode",{parentName:"li"},"ModelFramework or str"),"): the model framework used to train the model."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"model_server")," (",(0,r.kt)("inlineCode",{parentName:"li"},"ModelServer or str"),"): the model server used to serve the model."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key_feature")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str or callable"),"): the feature that is used for joining the features together."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"prediction_output_schema")," (",(0,r.kt)("inlineCode",{parentName:"li"},"TypedDict"),"): the schema of the prediction output."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name")," (",(0,r.kt)("inlineCode",{parentName:"li"},"str"),"): the name of the model. If not provided, the name will be the function name.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"a training function with provided context."))}m.isMDXComponent=!0}}]);