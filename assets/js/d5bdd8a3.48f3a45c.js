"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[62],{4907:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var a=t(9953);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(t),f=i,u=m["".concat(p,".").concat(f)]||m[f]||c[f]||r;return t?a.createElement(u,o(o({ref:n},d),{},{components:t})):a.createElement(u,o({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=f;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},5053:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(1943),i=(t(9953),t(4907));const r={},o="Name binding and variables",l={unversionedId:"reference/pyexp/pyexp-language-definition/name-binding-and-variables",id:"reference/pyexp/pyexp-language-definition/name-binding-and-variables",title:"Name binding and variables",description:"After a Starlark file is parsed, but before its execution begins, the Starlark interpreter checks statically that the program is well formed. For example, break and continue statements may appear only within a loop; a return statement may appear only within a function; and load statements may appear only outside any function.",source:"@site/docs/reference/pyexp/pyexp-language-definition/name-binding-and-variables.md",sourceDirName:"reference/pyexp/pyexp-language-definition",slug:"/reference/pyexp/pyexp-language-definition/name-binding-and-variables",permalink:"/docs/reference/pyexp/pyexp-language-definition/name-binding-and-variables",draft:!1,editUrl:"https://github.com/raptor-ml/docs/tree/master/docs/reference/pyexp/pyexp-language-definition/name-binding-and-variables.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Lexical elements",permalink:"/docs/reference/pyexp/pyexp-language-definition/lexical-elements"},next:{title:"Statements",permalink:"/docs/reference/pyexp/pyexp-language-definition/statements"}},p={},s=[],d={toc:s};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"name-binding-and-variables"},"Name binding and variables"),(0,i.kt)("p",null,"After a Starlark file is parsed, but before its execution begins, the Starlark interpreter checks statically that the program is well formed. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," statements may appear only within a loop; a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement may appear only within a function; and ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," statements may appear only outside any function."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Name resolution")," is the static checking process that resolves names to variable bindings. During execution, names refer to variables. Statically, names denote places in the code where variables are created; these places are called ",(0,i.kt)("em",{parentName:"p"},"bindings"),". A name may denote different bindings at different places in the program. The region of text in which a particular name refers to the same binding is called that binding's ",(0,i.kt)("em",{parentName:"p"},"scope"),"."),(0,i.kt)("p",null,"Four Starlark constructs bind names, as illustrated in the example below: ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," statements (",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"), ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statements (",(0,i.kt)("inlineCode",{parentName:"p"},"c"),"), function parameters (",(0,i.kt)("inlineCode",{parentName:"p"},"d"),"), and assignments (",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"h"),", including the augmented assignment ",(0,i.kt)("inlineCode",{parentName:"p"},"e += 1"),"). Variables may be assigned or re-assigned explicitly (",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"h"),"), or implicitly, as in a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop (",(0,i.kt)("inlineCode",{parentName:"p"},"f"),") or comprehension (",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'load("lib.star", "a", b="B")\n\ndef c(d):\n  e = 0\n  for f in d:\n     print([True for g in f])\n     e += 1\n\nh = [2*i for i in a]\n')),(0,i.kt)("p",null,"The environment of a Starlark program is structured as a tree of ",(0,i.kt)("em",{parentName:"p"},"lexical blocks"),", each of which may contain name bindings. The tree of blocks is parallel to the syntax tree. Blocks are of five kinds."),(0,i.kt)("p",null,"At the root of the tree is the ",(0,i.kt)("em",{parentName:"p"},"predeclared")," block, which binds several names implicitly. The set of predeclared names includes the universal constant values ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", and various built-in functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),"; these functions are immutable and stateless. An application may pre-declare additional names to provide domain-specific functions to that file, for example. These additional functions may have side effects on the application. Starlark programs cannot change the set of predeclared bindings or assign new values to them."),(0,i.kt)("p",null,"Nested beneath the predeclared block is the ",(0,i.kt)("em",{parentName:"p"},"module")," block, which contains the bindings of the current module. Bindings in the module block (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," in the example) are called ",(0,i.kt)("em",{parentName:"p"},"global")," and may be visible to other modules. The module block is empty at the start of the file and is populated by top-level binding statements."),(0,i.kt)("p",null,"Nested beneath the module block is the ",(0,i.kt)("em",{parentName:"p"},"file")," block, which contains bindings local to the current file. Names in this block (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," in the example) are bound only by ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," statements. The sets of names bound in the file block and in the module block do not overlap: it is an error for a load statement to bind the name of a global, or for a top-level statement to bind a name bound by a load statement."),(0,i.kt)("p",null,"A file block contains a ",(0,i.kt)("em",{parentName:"p"},"function")," block for each top-level function, and a ",(0,i.kt)("em",{parentName:"p"},"comprehension")," block for each top-level comprehension. Bindings in either of these kinds of block, and in the file block itself, are called ",(0,i.kt)("em",{parentName:"p"},"local"),". (In the example, the bindings for ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," are all local.) Additional functions and comprehensions, and their blocks, may be nested in any order, to any depth."),(0,i.kt)("p",null,"If name is bound anywhere within a block, all uses of the name within the block are treated as references to that binding, even if the use appears before the binding. This is true even at the top level, unlike Python. The binding of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," on the last line of the example below makes ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," local to the function ",(0,i.kt)("inlineCode",{parentName:"p"},"hello"),", so the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," in the print statement also refers to the local ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", even though it appears earlier."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'y = "goodbye"\n\ndef hello():\n  for x in (1, 2):\n    if x == 2:\n      print(y) # prints "hello"\n    if x == 1:\n      y = "hello"\n')),(0,i.kt)("p",null,"It is a dynamic error to evaluate a reference to a local variable before it has been bound:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def f():\n  print(x)              # dynamic error: local variable x referenced before assignment\n  x = "hello"\n')),(0,i.kt)("p",null,"The same is true for global variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'print(x)                # dynamic error: global variable x referenced before assignment\nx = "hello"\n')),(0,i.kt)("p",null,"The same is also true for nested loops in comprehensions. In the (unnatural) examples below, the scope of the variables ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," is the entire compehension block, except the operand of the first loop (",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[1]"),"), which is resolved in the enclosing environment. The second loop may thus refer to variables defined by the third (",(0,i.kt)("inlineCode",{parentName:"p"},"z"),"), even though such references would fail if actually executed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[1//0 for x in [] for y in z for z in ()]   # []   (no error)\n[1//0 for x in [1] for y in z for z in ()]  # dynamic error: local variable z referenced before assignment\n")),(0,i.kt)("p",null,"It is a static error to refer to a name that has no binding at all."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def f():\n  if False:\n    g()                   # static error: undefined: g\n")),(0,i.kt)("p",null,"(This behavior differs from Python, which treats such references as global, and thus does not report an error until the expression is evaluated.)"),(0,i.kt)("p",null,"It is a static error to bind a global variable already explicitly bound in the file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = 1\nx = 2                   # static error: cannot reassign global x declared on line 1\n")),(0,i.kt)("p",null,"If a name was pre-bound by the application, the Starlark program may explicitly bind it, but only once."),(0,i.kt)("p",null,"An augmented assignment statement such as ",(0,i.kt)("inlineCode",{parentName:"p"},"x += y")," is considered both a reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and a binding use of ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", so it may not be used at top level."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The Go implementation of Starlark permits augmented assignments to appear at top level if the ",(0,i.kt)("inlineCode",{parentName:"p"},"-globalreassign")," flag is enabled."),(0,i.kt)("p",null,"A function may refer to variables defined in an enclosing function. In this example, the inner function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," refers to a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," that is local to the outer function ",(0,i.kt)("inlineCode",{parentName:"p"},"squarer"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a ",(0,i.kt)("em",{parentName:"p"},"free variable")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),". The function value (",(0,i.kt)("inlineCode",{parentName:"p"},"f"),") created by a ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statement holds a reference to each of its free variables so it may use them even after the enclosing function has returned."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def squarer():\n    x = [0]\n    def f():\n      x[0] += 1\n      return x[0]*x[0]\n    return f\n\nsq = squarer()\nprint(sq(), sq(), sq(), sq()) # "1 4 9 16"\n')),(0,i.kt)("p",null,"An inner function cannot assign to a variable bound in an enclosing function, because the assignment would bind the variable in the inner function. In the example below, the ",(0,i.kt)("inlineCode",{parentName:"p"},"x += 1")," statement binds ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," within ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", hiding the outer ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". Execution fails because the inner ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," has not been assigned before the attempt to increment it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def squarer():\n    x = 0\n    def f():\n      x += 1            # dynamic error: local variable x referenced before assignment\n      return x*x\n    return f\n\nsq = squarer()\n")),(0,i.kt)("p",null,"(Starlark has no equivalent of Python's ",(0,i.kt)("inlineCode",{parentName:"p"},"nonlocal")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"global")," declarations, but as the first version of ",(0,i.kt)("inlineCode",{parentName:"p"},"squarer")," showed, this omission can be worked around by using a list of a single element.)"),(0,i.kt)("p",null,"A name appearing after a dot, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"split")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"get_filename().split('/')"),", is not resolved statically. The ",(0,i.kt)("a",{parentName:"p",href:"expressions#dot-expressions"},"dot expression")," ",(0,i.kt)("inlineCode",{parentName:"p"},".split")," is a dynamic operation on the value returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"get_filename()"),"."))}m.isMDXComponent=!0}}]);