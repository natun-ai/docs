"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1100],{4907:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(9953);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(s,".").concat(c)]||u[c]||d[c]||r;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4921:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(1943),i=(n(9953),n(4907));const r={},o="Data types",l={unversionedId:"reference/pyexp/pyexp-language-definition/data-types",id:"reference/pyexp/pyexp-language-definition/data-types",title:"Data types",description:"These are the main data types built in to the interpreter:",source:"@site/docs/reference/pyexp/pyexp-language-definition/data-types.md",sourceDirName:"reference/pyexp/pyexp-language-definition",slug:"/reference/pyexp/pyexp-language-definition/data-types",permalink:"/docs/reference/pyexp/pyexp-language-definition/data-types",draft:!1,editUrl:"https://github.com/raptor-ml/docs/tree/master/docs/reference/pyexp/pyexp-language-definition/data-types.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Built-in methods",permalink:"/docs/reference/pyexp/pyexp-language-definition/built-in-methods"},next:{title:"Expressions",permalink:"/docs/reference/pyexp/pyexp-language-definition/expressions"}},s={},p=[{value:"None",id:"none",level:2},{value:"Booleans",id:"booleans",level:2},{value:"Integers",id:"integers",level:2},{value:"Floating-point numbers",id:"floating-point-numbers",level:2},{value:"Strings",id:"strings",level:2},{value:"Lists",id:"lists",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Dictionaries",id:"dictionaries",level:2},{value:"Sets",id:"sets",level:2},{value:"Functions",id:"functions",level:2},{value:"Built-in functions",id:"built-in-functions",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-types"},"Data types"),(0,i.kt)("p",null,"These are the main data types built in to the interpreter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"NoneType                     # the type of None\nbool                         # True or False\nint                          # a signed integer of arbitrary magnitude\nfloat                        # an IEEE 754 double-precision floating point number\nstring                       # a byte string\nlist                         # a modifiable sequence of values\ntuple                        # an unmodifiable sequence of values\ndict                         # a mapping from values to values\nset                          # a set of values\nfunction                     # a function implemented in Starlark\nbuiltin_function_or_method   # a function or method implemented by the interpreter or host application\n")),(0,i.kt)("p",null,"Some functions, such as the iteration methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", or the ",(0,i.kt)("inlineCode",{parentName:"p"},"range")," function, return instances of special-purpose types that don't appear in this list. Additional data types may be defined by the host application into which the interpreter is embedded, and those data types may participate in basic operations of the language such as arithmetic, comparison, indexing, and function calls."),(0,i.kt)("p",null,"Some operations can be applied to any Starlark value. For example, every value has a type string that can be obtained with the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"type(x)"),", and any value may be converted to a string using the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"str(x)"),", or to a Boolean truth value using the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"bool(x)"),". Other operations apply only to certain types. For example, the indexing operation ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," works only with strings, lists, and tuples, and any application-defined types that are ",(0,i.kt)("em",{parentName:"p"},"indexable"),". The ",(0,i.kt)("a",{parentName:"p",href:"value-concepts"},(0,i.kt)("em",{parentName:"a"},"value concepts"))," section explains the groupings of types by the operators they support."),(0,i.kt)("h2",{id:"none"},"None"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"None")," is a distinguished value used to indicate the absence of any other value. For example, the result of a call to a function that contains no return statement is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"None")," is equal only to itself. Its ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"NoneType"'),". The truth value of ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,i.kt)("h2",{id:"booleans"},"Booleans"),(0,i.kt)("p",null,"There are two Boolean values, ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", representing the truth or falsehood of a predicate. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a Boolean is ",(0,i.kt)("inlineCode",{parentName:"p"},'"bool"'),"."),(0,i.kt)("p",null,"Boolean values are typically used as conditions in ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"-statements, although any Starlark value used as a condition is implicitly interpreted as a Boolean. For example, the values ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0.0"),", and the empty sequences ",(0,i.kt)("inlineCode",{parentName:"p"},'""'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," have a truth value of ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", whereas non-zero numbers and non-empty sequences have a truth value of ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),". Application-defined types determine their own truth value. Any value may be explicitly converted to a Boolean using the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'1 + 1 == 2                              # True\n2 + 2 == 5                              # False\n\nif 1 + 1:\n        print("True")\nelse:\n        print("False")\n')),(0,i.kt)("h2",{id:"integers"},"Integers"),(0,i.kt)("p",null,"The Starlark integer type represents integers. Its ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"int"'),"."),(0,i.kt)("p",null,"Integers may be positive or negative, and arbitrarily large. Integer arithmetic is exact. Integers are totally ordered; comparisons follow mathematical tradition."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," operators perform addition and subtraction, respectively. The ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator performs multiplication."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"//")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," operations on integers compute floored division and remainder of floored division, respectively. If the signs of the operands differ, the sign of the remainder ",(0,i.kt)("inlineCode",{parentName:"p"},"x % y")," matches that of the divisor, ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),". For all finite x and y (y \u2260 0), ",(0,i.kt)("inlineCode",{parentName:"p"},"(x // y) * y + (x % y) == x"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," operator implements real division, and yields a ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," result even when its operands are both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("p",null,"Integers, including negative values, may be interpreted as bit vectors. The ",(0,i.kt)("inlineCode",{parentName:"p"},"|"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," operators implement bitwise OR, AND, and XOR, respectively. The unary ",(0,i.kt)("inlineCode",{parentName:"p"},"~")," operator yields the bitwise inversion of its integer argument. The ",(0,i.kt)("inlineCode",{parentName:"p"},"<<")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," operators shift the first argument to the left or right by the number of bits given by the second argument."),(0,i.kt)("p",null,"Any bool, number, or string may be interpreted as an integer by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," built-in function."),(0,i.kt)("p",null,"An integer used in a Boolean context is considered true if it is non-zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'100 // 5 * 9 + 32               # 212\n3 // 2                          # 1\n3 / 2                           # 1.5\n111111111 * 111111111           # 12345678987654321\n"0x%x" % (0x1234 & 0xf00f)      # "0x1004"\nint("ffff", 16)                 # 65535, 0xffff\n')),(0,i.kt)("h2",{id:"floating-point-numbers"},"Floating-point numbers"),(0,i.kt)("p",null,"The Starlark floating-point data type represents an IEEE 754 double-precision floating-point number. Its ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"float"'),"."),(0,i.kt)("p",null,"Arithmetic on floats using the ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"/"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"//"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," operators follows the IEE 754 standard. However, computing the division or remainder of division by zero is a dynamic error."),(0,i.kt)("p",null,"An arithmetic operation applied to a mixture of ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," operands works as if the ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," operand is first converted to a ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),". For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"3.141 + 1")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"3.141 + float(1)"),". There are two floating-point division operators: ",(0,i.kt)("inlineCode",{parentName:"p"},"x / y")," yields the floating-point quotient of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"x // y")," yields ",(0,i.kt)("inlineCode",{parentName:"p"},"floor(x / y)"),", that is, the largest integer value not greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"x / y"),". Although the resulting number is integral, it is represented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," if either operand is a ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," operation computes the remainder of floored division. As with the corresponding operation on integers, if the signs of the operands differ, the sign of the remainder ",(0,i.kt)("inlineCode",{parentName:"p"},"x % y")," matches that of the divisor, ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("p",null,"The infinite float values ",(0,i.kt)("inlineCode",{parentName:"p"},"+Inf")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-Inf")," represent numbers greater/less than all finite float values."),(0,i.kt)("p",null,"The non-finite ",(0,i.kt)("inlineCode",{parentName:"p"},"NaN")," value represents the result of dubious operations such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Inf/Inf"),". A NaN value compares neither less than, nor greater than, nor equal to any value, including itself."),(0,i.kt)("p",null,"All floats other than NaN are totally ordered, so they may be compared using operators such as ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),"."),(0,i.kt)("p",null,"Any bool, number, or string may be interpreted as a floating-point number by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," built-in function."),(0,i.kt)("p",null,"A float used in a Boolean context is considered true if it is non-zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"1.23e45 * 1.23e45                               # 1.5129e+90\n1.111111111111111 * 1.111111111111111           # 1.23457\n3.0 / 2                                         # 1.5\n3 / 2.0                                         # 1.5\nfloat(3) / 2                                    # 1.5\n3.0 // 2.0                                      # 1.0\n")),(0,i.kt)("h2",{id:"strings"},"Strings"),(0,i.kt)("p",null,"A string represents an immutable sequence of bytes. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a string is ",(0,i.kt)("inlineCode",{parentName:"p"},'"string"'),"."),(0,i.kt)("p",null,"Strings can represent arbitrary binary data, including zero bytes, but most strings contain text, encoded by convention using UTF-8."),(0,i.kt)("p",null,"The built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," function returns the number of bytes in a string."),(0,i.kt)("p",null,"Strings may be concatenated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator."),(0,i.kt)("p",null,"The substring expression ",(0,i.kt)("inlineCode",{parentName:"p"},"s[i:j]")," returns the substring of ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," from index ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," up to index ",(0,i.kt)("inlineCode",{parentName:"p"},"j"),". The index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"s[i]")," returns the 1-byte substring ",(0,i.kt)("inlineCode",{parentName:"p"},"s[i:i+1]"),"."),(0,i.kt)("p",null,"Strings are hashable, and thus may be used as keys in a dictionary."),(0,i.kt)("p",null,"Strings are totally ordered lexicographically, so strings may be compared using operators such as ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),"."),(0,i.kt)("p",null,"Strings are ",(0,i.kt)("em",{parentName:"p"},"not")," iterable sequences, so they cannot be used as the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop, list comprehension, or any other operation than requires an iterable sequence. To obtain a view of a string as an iterable sequence of numeric byte values, 1-byte substrings, numeric Unicode code points, or 1-code point substrings, you must explicitly call one of its four methods: ",(0,i.kt)("inlineCode",{parentName:"p"},"elems"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"elem_ords"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"codepoints"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"codepoint_ords"),"."),(0,i.kt)("p",null,"Any value may formatted as a string using the ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"repr")," built-in functions, the ",(0,i.kt)("inlineCode",{parentName:"p"},"str % tuple")," operator, or the ",(0,i.kt)("inlineCode",{parentName:"p"},"str.format")," method."),(0,i.kt)("p",null,"A string used in a Boolean context is considered true if it is non-empty."),(0,i.kt)("p",null,"Strings have several built-in methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringcapitalize"},(0,i.kt)("inlineCode",{parentName:"a"},"capitalize"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringcodepoint_ords"},(0,i.kt)("inlineCode",{parentName:"a"},"codepoint_ords"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringcodepoints"},(0,i.kt)("inlineCode",{parentName:"a"},"codepoints"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringcount"},(0,i.kt)("inlineCode",{parentName:"a"},"count"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringelem_ords"},(0,i.kt)("inlineCode",{parentName:"a"},"elem_ords"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringelems"},(0,i.kt)("inlineCode",{parentName:"a"},"elems"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringendswith"},(0,i.kt)("inlineCode",{parentName:"a"},"endswith"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringfind"},(0,i.kt)("inlineCode",{parentName:"a"},"find"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringformat"},(0,i.kt)("inlineCode",{parentName:"a"},"format"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringindex"},(0,i.kt)("inlineCode",{parentName:"a"},"index"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringisalnum"},(0,i.kt)("inlineCode",{parentName:"a"},"isalnum"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringisalpha"},(0,i.kt)("inlineCode",{parentName:"a"},"isalpha"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringisdigit"},(0,i.kt)("inlineCode",{parentName:"a"},"isdigit"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringislower"},(0,i.kt)("inlineCode",{parentName:"a"},"islower"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringisspace"},(0,i.kt)("inlineCode",{parentName:"a"},"isspace"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringistitle"},(0,i.kt)("inlineCode",{parentName:"a"},"istitle"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringisupper"},(0,i.kt)("inlineCode",{parentName:"a"},"isupper"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringjoin"},(0,i.kt)("inlineCode",{parentName:"a"},"join"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringlower"},(0,i.kt)("inlineCode",{parentName:"a"},"lower"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringlstrip"},(0,i.kt)("inlineCode",{parentName:"a"},"lstrip"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringpartition"},(0,i.kt)("inlineCode",{parentName:"a"},"partition"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringreplace"},(0,i.kt)("inlineCode",{parentName:"a"},"replace"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringrfind"},(0,i.kt)("inlineCode",{parentName:"a"},"rfind"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringrindex"},(0,i.kt)("inlineCode",{parentName:"a"},"rindex"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringrpartition"},(0,i.kt)("inlineCode",{parentName:"a"},"rpartition"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringrsplit"},(0,i.kt)("inlineCode",{parentName:"a"},"rsplit"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringrstrip"},(0,i.kt)("inlineCode",{parentName:"a"},"rstrip"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringsplit"},(0,i.kt)("inlineCode",{parentName:"a"},"split"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringsplitlines"},(0,i.kt)("inlineCode",{parentName:"a"},"splitlines"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringstartswith"},(0,i.kt)("inlineCode",{parentName:"a"},"startswith"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringstrip"},(0,i.kt)("inlineCode",{parentName:"a"},"strip"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringtitle"},(0,i.kt)("inlineCode",{parentName:"a"},"title"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#stringupper"},(0,i.kt)("inlineCode",{parentName:"a"},"upper")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The type of a string element varies across implementations. There is agreement that byte strings, with text conventionally encoded using UTF-8, is the ideal choice, but the Java implementation treats strings as sequences of UTF-16 codes and changing it appears intractible; see Google Issue b/36360490."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The Java implementation does not consistently treat strings as iterable; see ",(0,i.kt)("inlineCode",{parentName:"p"},"testdata/string.star")," in the test suite and Google Issue b/34385336 for further details."),(0,i.kt)("h2",{id:"lists"},"Lists"),(0,i.kt)("p",null,"A list is a mutable sequence of values. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a list is ",(0,i.kt)("inlineCode",{parentName:"p"},'"list"'),"."),(0,i.kt)("p",null,"Lists are indexable sequences: the elements of a list may be iterated over by ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loops, list comprehensions, and various built-in functions."),(0,i.kt)("p",null,"List may be constructed using bracketed list notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[]              # an empty list\n[1]             # a 1-element list\n[1, 2]          # a 2-element list\n")),(0,i.kt)("p",null,"Lists can also be constructed from any iterable sequence by using the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," function."),(0,i.kt)("p",null,"The built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," function applied to a list returns the number of elements. The index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"list[i]")," returns the element at index i, and the slice expression ",(0,i.kt)("inlineCode",{parentName:"p"},"list[i:j]")," returns a new list consisting of the elements at indices from i to j."),(0,i.kt)("p",null,"List elements may be added using the ",(0,i.kt)("inlineCode",{parentName:"p"},"append")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"extend")," methods, removed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"remove")," method, or reordered by assignments such as ",(0,i.kt)("inlineCode",{parentName:"p"},"list[i] = list[j]"),"."),(0,i.kt)("p",null,"The concatenation operation ",(0,i.kt)("inlineCode",{parentName:"p"},"x + y")," yields a new list containing all the elements of the two lists x and y."),(0,i.kt)("p",null,"For most types, ",(0,i.kt)("inlineCode",{parentName:"p"},"x += y")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"x = x + y"),", except that it evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," only once, that is, it allocates a new list to hold the concatenation of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),". However, if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," refers to a list, the statement does not allocate a new list but instead mutates the original list in place, similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"x.extend(y)"),"."),(0,i.kt)("p",null,"Lists are not hashable, so may not be used in the keys of a dictionary."),(0,i.kt)("p",null,"A list used in a Boolean context is considered true if it is non-empty."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"expressions#Comprehensions"},(0,i.kt)("em",{parentName:"a"},"list comprehension"))," creates a new list whose elements are the result of some expression applied to each element of another sequence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[x*x for x in [1, 2, 3, 4]]      # [1, 4, 9, 16]\n")),(0,i.kt)("p",null,"A list value has these methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listappend"},(0,i.kt)("inlineCode",{parentName:"a"},"append"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listclear"},(0,i.kt)("inlineCode",{parentName:"a"},"clear"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listextend"},(0,i.kt)("inlineCode",{parentName:"a"},"extend"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listindex"},(0,i.kt)("inlineCode",{parentName:"a"},"index"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listinsert"},(0,i.kt)("inlineCode",{parentName:"a"},"insert"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listpop"},(0,i.kt)("inlineCode",{parentName:"a"},"pop"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#listremove"},(0,i.kt)("inlineCode",{parentName:"a"},"remove")))),(0,i.kt)("h2",{id:"tuples"},"Tuples"),(0,i.kt)("p",null,"A tuple is an immutable sequence of values. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a tuple is ",(0,i.kt)("inlineCode",{parentName:"p"},'"tuple"'),"."),(0,i.kt)("p",null,"Tuples are constructed using parenthesized list notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'()                      # the empty tuple\n(1,)                    # a 1-tuple\n(1, 2)                  # a 2-tuple ("pair")\n(1, 2, 3)               # a 3-tuple\n')),(0,i.kt)("p",null,"Observe that for the 1-tuple, the trailing comma is necessary to distinguish it from the parenthesized expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(1)"),". 1-tuples are seldom used."),(0,i.kt)("p",null,"Starlark, unlike Python, does not permit a trailing comma to appear in an unparenthesized tuple expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"for k, v, in dict.items(): pass                 # syntax error at 'in'\n_ = [(v, k) for k, v, in dict.items()]          # syntax error at 'in'\nf = lambda a, b, : None                         # syntax error at ':'\n\nsorted(3, 1, 4, 1,)                             # ok\n[1, 2, 3, ]                                     # ok\n{1: 2, 3:4, }                                   # ok\n")),(0,i.kt)("p",null,"Any iterable sequence may be converted to a tuple by using the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple")," function."),(0,i.kt)("p",null,"Like lists, tuples are indexed sequences, so they may be indexed and sliced. The index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple[i]")," returns the tuple element at index i, and the slice expression ",(0,i.kt)("inlineCode",{parentName:"p"},"tuple[i:j]")," returns a sub-sequence of a tuple."),(0,i.kt)("p",null,"Tuples are iterable sequences, so they may be used as the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop, a list comprehension, or various built-in functions."),(0,i.kt)("p",null,"Unlike lists, tuples cannot be modified. However, the mutable elements of a tuple may be modified."),(0,i.kt)("p",null,"Tuples are hashable (assuming their elements are hashable), so they may be used as keys of a dictionary."),(0,i.kt)("p",null,"Tuples may be concatenated using the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator."),(0,i.kt)("p",null,"A tuple used in a Boolean context is considered true if it is non-empty."),(0,i.kt)("h2",{id:"dictionaries"},"Dictionaries"),(0,i.kt)("p",null,"A dictionary is a mutable mapping from keys to values. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a dictionary is ",(0,i.kt)("inlineCode",{parentName:"p"},'"dict"'),"."),(0,i.kt)("p",null,"Dictionaries provide constant-time operations to insert an element, to look up the value for a key, or to remove an element. Dictionaries are implemented using hash tables, so keys must be hashable. Hashable values include ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", Booleans, numbers, and strings, and tuples composed from hashable values. Most mutable values, such as lists, dictionaries, and sets, are not hashable, even when frozen. Attempting to use a non-hashable value as a key in a dictionary results in a dynamic error."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"expressions#dictionary-expressions"},"dictionary expression")," specifies a dictionary as a set of key/value pairs enclosed in braces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'coins = {\n  "penny": 1,\n  "nickel": 5,\n  "dime": 10,\n  "quarter": 25,\n}\n')),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"d[k]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is a dictionary and ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," is a key, retrieves the value associated with the key. If the dictionary contains no such item, the operation fails:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'coins["penny"]          # 1\ncoins["dime"]           # 10\ncoins["silver dollar"]  # error: key not found\n')),(0,i.kt)("p",null,"The number of items in a dictionary ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is given by ",(0,i.kt)("inlineCode",{parentName:"p"},"len(d)"),". A key/value item may be added to a dictionary, or updated if the key is already present, by using ",(0,i.kt)("inlineCode",{parentName:"p"},"d[k]")," on the left side of an assignment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'len(coins)              # 4\ncoins["shilling"] = 20\nlen(coins)              # 5, item was inserted\ncoins["shilling"] = 5\nlen(coins)              # 5, existing item was updated\n')),(0,i.kt)("p",null,"A dictionary can also be constructed using a ",(0,i.kt)("a",{parentName:"p",href:"expressions#comprehensions"},"dictionary comprehension"),", which evaluates a pair of expressions, the ",(0,i.kt)("em",{parentName:"p"},"key")," and the ",(0,i.kt)("em",{parentName:"p"},"value"),", for every element of another iterable such as a list. This example builds a mapping from each word to its length in bytes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'words = ["able", "baker", "charlie"]\n{x: len(x) for x in words}  # {"charlie": 7, "baker": 5, "able": 4}\n')),(0,i.kt)("p",null,"Dictionaries are iterable sequences, so they may be used as the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop, a list comprehension, or various built-in functions. Iteration yields the dictionary's keys in the order in which they were inserted; updating the value associated with an existing key does not affect the iteration order."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'x = dict([("a", 1), ("b", 2)])          # {"a": 1, "b": 2}\nx.update([("a", 3), ("c", 4)])          # {"a": 3, "b": 2, "c": 4}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'for name in coins:\n  print(name, coins[name])  # prints "quarter 25", "dime 10", ...\n')),(0,i.kt)("p",null,"Like all mutable values in Starlark, a dictionary can be frozen, and once frozen, all subsequent operations that attempt to update it will fail."),(0,i.kt)("p",null,"A dictionary used in a Boolean context is considered true if it is non-empty."),(0,i.kt)("p",null,"Dictionaries may be compared for equality using ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!="),". Two dictionaries compare equal if they contain the same number of items and each key/value item (k, v) found in one dictionary is also present in the other. Dictionaries are not ordered; it is an error to compare two dictionaries with ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),"."),(0,i.kt)("p",null,"A dictionary value has these methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictclear"},(0,i.kt)("inlineCode",{parentName:"a"},"clear"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictget"},(0,i.kt)("inlineCode",{parentName:"a"},"get"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictitems"},(0,i.kt)("inlineCode",{parentName:"a"},"items"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictkeys"},(0,i.kt)("inlineCode",{parentName:"a"},"keys"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictpop"},(0,i.kt)("inlineCode",{parentName:"a"},"pop"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictpopitem"},(0,i.kt)("inlineCode",{parentName:"a"},"popitem"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictsetdefault"},(0,i.kt)("inlineCode",{parentName:"a"},"setdefault"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictupdate"},(0,i.kt)("inlineCode",{parentName:"a"},"update"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"built-in-methods#dictvalues"},(0,i.kt)("inlineCode",{parentName:"a"},"values")))),(0,i.kt)("h2",{id:"sets"},"Sets"),(0,i.kt)("p",null,"A set is a mutable set of values. The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a set is ",(0,i.kt)("inlineCode",{parentName:"p"},'"set"'),"."),(0,i.kt)("p",null,"Like dictionaries, sets are implemented using hash tables, so the elements of a set must be hashable."),(0,i.kt)("p",null,"Sets may be compared for equality or inequality using ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!="),". Two sets compare equal if they contain the same elements."),(0,i.kt)("p",null,"Sets are iterable sequences, so they may be used as the operand of a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"-loop, a list comprehension, or various built-in functions. Iteration yields the set's elements in the order in which they were inserted."),(0,i.kt)("p",null,"The binary ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operators compute union and intersection when applied to sets. The right operand of the ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," operator may be any iterable value. The binary ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," operator performs a set membership test when its right operand is a set."),(0,i.kt)("p",null,"The binary ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," operator performs symmetric difference of two sets."),(0,i.kt)("p",null,"Sets are instantiated by calling the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," function, which returns a set containing all the elements of its optional argument, which must be an iterable sequence. Sets have no literal syntax."),(0,i.kt)("p",null,"The only method of a set is ",(0,i.kt)("inlineCode",{parentName:"p"},"union"),", which is equivalent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," operator."),(0,i.kt)("p",null,"A set used in a Boolean context is considered true if it is non-empty."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The Go implementation of Starlark requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"-set")," flag to enable support for sets. The Java implementation does not support sets."),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("p",null,"A function value represents a function defined in Starlark. Its ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'"function"'),". A function value used in a Boolean context is always considered true."),(0,i.kt)("p",null,"Functions defined by a ",(0,i.kt)("a",{parentName:"p",href:"statements#function-definitions"},(0,i.kt)("inlineCode",{parentName:"a"},"def")," statement")," are named; functions defined by a ",(0,i.kt)("a",{parentName:"p",href:"expressions#lambda-expressions"},(0,i.kt)("inlineCode",{parentName:"a"},"lambda")," expression")," are anonymous."),(0,i.kt)("p",null,"Function definitions may be nested, and an inner function may refer to a local variable of an outer function."),(0,i.kt)("p",null,"A function definition defines zero or more named parameters. Starlark has a rich mechanism for passing arguments to functions."),(0,i.kt)("p",null,"The example below shows a definition and call of a function of two required parameters, ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def idiv(x, y):\n  return x // y\n\nidiv(6, 3)      # 2\n")),(0,i.kt)("p",null,"A call may provide arguments to function parameters either by position, as in the example above, or by name, as in first two calls below, or by a mixture of the two forms, as in the third call below. All the positional arguments must precede all the named arguments. Named arguments may improve clarity, especially in functions of several parameters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"idiv(x=6, y=3)      # 2\nidiv(y=3, x=6)      # 2\n\nidiv(6, y=3)        # 2\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Optional parameters:")," A parameter declaration may specify a default value using ",(0,i.kt)("inlineCode",{parentName:"p"},"name=value")," syntax; such a parameter is ",(0,i.kt)("em",{parentName:"p"},"optional"),". The default value expression is evaluated during execution of the ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statement or evaluation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expression, and the default value forms part of the function value. All optional parameters must follow all non-optional parameters. A function call may omit arguments for any suffix of the optional parameters; the effective values of those arguments are supplied by the function's parameter defaults."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def f(x, y=3):\n  return x, y\n\nf(1, 2) # (1, 2)\nf(1)    # (1, 3)\n")),(0,i.kt)("p",null,"If a function parameter's default value is a mutable expression, modifications to the value during one call may be observed by subsequent calls. Beware of this when using lists or dicts as default values. If the function becomes frozen, its parameters' default values become frozen too."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# module a.star\ndef f(x, list=[]):\n  list.append(x)\n  return list\n\nf(4, [1,2,3])           # [1, 2, 3, 4]\nf(1)                    # [1]\nf(2)                    # [1, 2], not [2]!\n\n# module b.star\nload("a.star", "f")\nf(3)                    # error: cannot append to frozen list\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Variadic functions:")," Some functions allow callers to provide an arbitrary number of arguments. After all required and optional parameters, a function definition may specify a ",(0,i.kt)("em",{parentName:"p"},"variadic arguments")," or ",(0,i.kt)("em",{parentName:"p"},"varargs")," parameter, indicated by a star preceding the parameter name: ",(0,i.kt)("inlineCode",{parentName:"p"},"*args"),". Any surplus positional arguments provided by the caller are formed into a tuple and assigned to the ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def f(x, y, *args):\n  return x, y, args\n\nf(1, 2)                 # (1, 2, ())\nf(1, 2, 3, 4)           # (1, 2, (3, 4))\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Keyword-variadic functions:")," Some functions allow callers to provide an arbitrary sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"name=value")," keyword arguments. A function definition may include a final ",(0,i.kt)("em",{parentName:"p"},"keyword arguments")," or ",(0,i.kt)("em",{parentName:"p"},"kwargs")," parameter, indicated by a double-star preceding the parameter name: ",(0,i.kt)("inlineCode",{parentName:"p"},"**kwargs"),". Any surplus named arguments that do not correspond to named parameters are collected in a new dictionary and assigned to the ",(0,i.kt)("inlineCode",{parentName:"p"},"kwargs")," parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def f(x, y, **kwargs):\n  return x, y, kwargs\n\nf(1, 2)                 # (1, 2, {})\nf(x=2, y=1)             # (2, 1, {})\nf(x=2, y=1, z=3)        # (2, 1, {"z": 3})\n')),(0,i.kt)("p",null,"It is a static error if any two parameters of a function have the same name."),(0,i.kt)("p",null,"Just as a function definition may accept an arbitrary number of positional or named arguments, a function call may provide an arbitrary number of positional or named arguments supplied by a list or dictionary:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def f(a, b, c=5):\n  return a * b + c\n\nf(*[2, 3])              # 11\nf(*[2, 3, 7])           # 13\nf(*[2])                 # error: f takes at least 2 arguments (1 given)\n\nf(**dict(b=3, a=2))             # 11\nf(**dict(c=7, a=2, b=3))        # 13\nf(**dict(a=2))                  # error: f takes at least 2 arguments (1 given)\nf(**dict(d=4))                  # error: f got unexpected keyword argument "d"\n')),(0,i.kt)("p",null,"Once the parameters have been successfully bound to the arguments supplied by the call, the sequence of statements that comprise the function body is executed."),(0,i.kt)("p",null,"It is a static error if a function call has two named arguments of the same name, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"f(x=1, x=2)"),". A call that provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"**kwargs")," argument may yet have two values for the same name, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"f(x=1, **dict(x=2))"),". This results in a dynamic error."),(0,i.kt)("p",null,"Function arguments are evaluated in the order they appear in the call."),(0,i.kt)("p",null,"Unlike Python, Starlark does not allow more than one ",(0,i.kt)("inlineCode",{parentName:"p"},"*args")," argument in a call, and if a ",(0,i.kt)("inlineCode",{parentName:"p"},"*args")," argument is present it must appear after all positional and named arguments."),(0,i.kt)("p",null,"The final argument to a function call may be followed by a trailing comma."),(0,i.kt)("p",null,"A function call completes normally after the execution of either a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement, or of the last statement in the function body. The result of the function call is the value of the return statement's operand, or ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the return statement had no operand or if the function completeted without executing a return statement."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def f(x):\n  if x == 0:\n    return\n  if x < 0:\n    return -x\n  print(x)\n\nf(1)            # returns None after printing "1"\nf(0)            # returns None without printing\nf(-1)           # returns 1 without printing\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation note:")," The Go implementation of Starlark requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"-recursion")," flag to allow recursive functions."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"-recursion")," flag is not specified it is a dynamic error for a function to call itself or another function value with the same declaration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def fib(x):\n  if x < 2:\n    return x\n  return fib(x-2) + fib(x-1)    # dynamic error: function fib called recursively\n\nfib(5)\n")),(0,i.kt)("p",null,"This rule, combined with the invariant that all loops are iterations over finite sequences, implies that Starlark programs can not be Turing complete unless the ",(0,i.kt)("inlineCode",{parentName:"p"},"-recursion")," flag is specified."),(0,i.kt)("h2",{id:"built-in-functions"},"Built-in functions"),(0,i.kt)("p",null,"A built-in function is a function or method implemented in Go by the interpreter or the application into which the interpreter is embedded."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"built-in-constants-and-functions#type"},"type")," of a built-in function is ",(0,i.kt)("inlineCode",{parentName:"p"},'"builtin_function_or_method"'),"."),(0,i.kt)("p",null,"A built-in function value used in a Boolean context is always considered true."),(0,i.kt)("p",null,"Many built-in functions are predeclared in the environment (see ",(0,i.kt)("a",{parentName:"p",href:"name-binding-and-variables"},"Name Resolution"),"). Some built-in functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," are ",(0,i.kt)("em",{parentName:"p"},"universal"),", that is, available to all Starlark programs. The host application may predeclare additional built-in functions in the environment of a specific module."),(0,i.kt)("p",null,"Except where noted, built-in functions accept only positional arguments. The parameter names serve merely as documentation."),(0,i.kt)("p",null,"Most built-in functions that have a Boolean parameter require its argument to be ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),". Unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements, other values are not implicitly converted to their truth value and instead cause a dynamic error."))}u.isMDXComponent=!0}}]);